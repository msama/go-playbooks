#Http request caching

This playbook shows how to do http request caching by wrapping the DB logic with a cache inside the handler.

#Request hashing

The first step for caching responses is generating a request hash which the caching layer can use to uniquely fetch messages. That can be done by providinf a concrete implementation of the following function:

```
type hashFunction func(req *http.Request) string
```

#Request caching

The interface for caching requests is quite simple. It uses the unique key generated by `hashFunction` to store items.

```
type RequestCache interface {
	GetValue(key string) []byte
	SetValue(key string, val []byte)
}
```

#Handling requests

The `http.Handler` internally query the cache first and if that misses then try the database.


```
func (h *jsonCacheHandler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	key := h.hashFn(req)
	var messageJson []byte

	// Attempt to read from the cache
	val := h.cache.GetValue(key)
	if val == nil {
		// If the cahce miss read from the db then update the cache
		log.Printf("Miss for key %s", key)
		message, err := h.db.QueryMessage(key)
		if err != nil {
			rw.WriteHeader(http.StatusInternalServerError)
			log.Printf("Error querying the DB: %s", err)
			return
		}
		val, err := json.Marshal(message)
		if err != nil {
			rw.WriteHeader(http.StatusInternalServerError)
			log.Printf("Error encoding: %s", err)
			return
		}
		messageJson = val
		h.cache.SetValue(key, val)
	} else {
		// If the cache hits retur its value
		log.Printf("Hit for key %s", key)
		messageJson = val
	}

	// Generate the response
	rw.WriteHeader(http.StatusOK)
	rw.Header().Add("Content-Type", "application/json")
	rw.Write(messageJson) // Ignore write/connection errors
}
```

