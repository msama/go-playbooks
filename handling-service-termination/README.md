#Handling service termination

This playbook shows how to handle service termination. GO and the `net/http` package already takes care of the most common aspects. This playbook shows how to solve common tasks.

##Gracefully recovering from panic

GO automatically isolates panic inside each handler so that when a panic occurs it only affects a single request. However the default configuration simply terminates the request without returning any response to the caller. However it is possible to handle the panic by still responding to client. Notice that this is only possible unless the response writer has already been generated. In the playbook for instance the response is partially generated by the original handler and half by the panic handler.

A way to handle panics is to wrap the real handler with a wapper handler which will defer and recover in case of panic.

```
func (h *panicHandler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	defer func() {
		panicData := recover()
		if panicData != nil {
			// Handle panics
			log.Printf("Just recovered from panic: %v\n", panicData)
			rw.WriteHeader(500)
			io.WriteString(rw, "An error occurred and was internally handled :)\n")
		}
	}()
	h.delegate.ServeHTTP(rw, req)
}
```

##Gracefully terminating

The first step for gracefully terminating is to handle errors from the `ListenAndServe` routine as well as signals.

```
func main() {

	// The service state
	serviceState := &ServiceState{
		Running: true,
	}

	// Handle termination signals
	errors := make(chan error, 1)
	signals := make(chan os.Signal, 1)
	signal.Notify(signals, os.Interrupt)
	signal.Notify(signals, syscall.SIGTERM)

	// Initialise the handlers
	// ...

	// Start serving
	go func() {
		err := http.ListenAndServe(":8080", nil)
		if err != nil {
			errors <- err
		}
	}()
  
	// Waits until the service fails or it is terminated.
	select {
	case err := <-errors:
		log.Printf("Error: %v\n", err)
		break
	case sig := <-signals:
		log.Printf("Signal: %v\n", sig)
		break
	}

	serviceState.Running = false
	i := 3
	for i > 0 {
		log.Printf("Terminating in %d\n", i)
		time.Sleep(1 * time.Second)
		i = i - 1
	}
}
```

Once errors and signals have been captured they can be properly handled. This playbook suggests to turn off the service gracefully by stopping serving new requests and by waiting for the ones in progress to terminate. Once again this can be done by wrapping the handler
with a state controller delegate that enforces some sort of service lifecycle. The state object in the playbook is only an example and can be improved.

Just a quick note about synchronization. In the playbook the `running` variable is not synchronised and in the common case there is no reason for it to be. Synchronising it would make the implementation slower and therefore it should only be done if there is a real reason. In the playbook example it doesn't really matter when requests stops being served as long as that happens quickly enough. In other systems it might be necessary to stop serving requests immediately as soon as other subcomponents are terminated and therefore the 
lifecycle need to be synchronised.


##Measuring how long the service was up

It is often interesting to measure how long the service has been running. Also while examinging the logs of a malfunctioning service it is often usefult to know if the main process is still running or if it has terminated and when. This can be done by deferring a function before invoking `ListenAndServe`.

```
// Used to print the uptime at the end of service execution
func PrintUptime(start time.Time) {
	now := time.Now()
	log.Printf("Service was running for %v\n", now.Sub(start))
	log.Printf("Service was terminated at %v\n", now)
}

func main() {
	// At the end of the execution prints how long the service was running.
	defer PrintUptime(time.Now())
}

```
